<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>
<body style="text-align:center; margin-left:auto; margin-right:auto;">

<canvas id="draw" width="1265" height="492"></canvas>

<script type="text/javascript">
  const canvas = document.querySelector('#draw');
  ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'lightgrey';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeRect(0, 0, canvas.width, canvas.height);

  const pixelSize = 30;
  let dt = 0.08;
  const visc = 6;
  const arrWidth = Math.floor(canvas.width / pixelSize);
  const arrHeight = Math.floor(canvas.height / pixelSize);

  // const u = [size], v[size], u_prev[size], v_p rev[size];
  // static dens[size], dens_prev[size];
  function initMatrix(x,y,val=function() { return 0; }) {
    const matrix = [];
    for(var i=0; i<x; i++) {
      let innerMat = [];
      for (let j=0; j<y; j++) {
        innerMat.push(val(i,j));
      }
      matrix[i] = innerMat;
    }
    return matrix;
  }

  function matrixDeepCopy(mat) {
    return mat.slice().map(el => el.slice());
  }

  class Vector {
    constructor(x, y) {
      this.objectType = this.constructor.name;
      this.x = x;
      this.y = y;
    }
    xDirection() { return this.x / Math.abs(this.x); }
    yDirection() { return this.y / Math.abs(this.y); }
  }

  // const newVec = function() { return new Vector(0,0) };
  // const newVec = function() { return (Math.random()-0.5)*0.01 };
  const newVecU = function(x,y) { return Math.sin(-0.002*x*y-10)*0.005 };
  const newVecV = function(x,y) { return Math.cos(-0.015*x*y-10)*-0.005 };
  // {10*Sin(-0.002*yx-10),-10*Cos(-0.015*yx-10)}
  let uState = initMatrix(arrWidth, arrHeight, newVecU);
  let vState = initMatrix(arrWidth, arrHeight, newVecV);
  let uPrev = matrixDeepCopy(uState);
  let vPrev = matrixDeepCopy(vState);
  const newScalar = function() { return Math.random() * 20; }
  let denState = initMatrix(arrWidth, arrHeight, newScalar);
  let denPrev = matrixDeepCopy(denState);

  function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "grey";
    for (let i=1; i<arrWidth+1; i++) {
      ctx.beginPath();
      ctx.moveTo(i*pixelSize, 0);
      ctx.lineTo(i*pixelSize, canvas.height);
      ctx.stroke();
    }
    for (let j=1; j<arrHeight+1; j++) {
      ctx.beginPath();
      ctx.moveTo(0, j*pixelSize);
      ctx.lineTo(canvas.width, j*pixelSize);
      ctx.stroke();
    }
  }
  drawCanvas();

  function canvas_arrow(fromX, fromY, toX, toY) {
    var headLength = 10;
    var dx = toX - fromX;
    var dy = toY - fromY;
    var angle = Math.atan2(dy, dx);
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
  }

  function drawVelocityArrows() {
    ctx.strokeStyle = "darkgrey";
    const displayAmplitude = 200;
    for (let i=0; i<arrWidth; i++) {
      for (let j=0; j<arrHeight; j++) {
        canvas_arrow(
          (i+1)*pixelSize-pixelSize/2.0,
          (j+1)*pixelSize-pixelSize/2.0,
          (i+1)*pixelSize-pixelSize/2.0 + pixelSize/2.0*uState[i][j]*displayAmplitude,
          (j+1)*pixelSize-pixelSize/2.0 + pixelSize/2.0*vState[i][j]*displayAmplitude
        );
        ctx.stroke();
      }
    }
  }
  drawVelocityArrows();

  function drawDensityCircles() {
    ctx.strokeStyle = "black";
    for (let i=0; i<arrWidth; i++) {
      for (let j=0; j<arrHeight; j++) {
        ctx.beginPath();
        ctx.arc(
          (i+1)*pixelSize-pixelSize/2.0,
          (j+1)*pixelSize-pixelSize/2.0,
          denState[i][j]*0.5,
          0, 2*Math.PI, false
        );
        ctx.stroke();
      }
    }
  }
  drawDensityCircles();
  drawVelocityArrows();

  function diffuse(b, x, x0, visc, dt) {
    const a=dt*visc*arrWidth*arrHeight;
    for (let k=0; k<20; k++ ) {
      for (let i=1; i<=arrWidth-2; i++ ) {
        for (let j=1; j<=arrHeight-2; j++ ) {
          x[i][j] = (
            x0[i][j] +
            a*(
              x[i-1][j]+
              x[i+1][j]+
              x[i][j-1]+
              x[i][j+1]
            )
          )/(1+4*a);
        }
      }
      // set_bnd ( N, b, x );
    }
  }

  function advect(b, d, d0, u, v, dt) {
    let x, y, s0, t0, s1, t1, dt0;
    dt0 = dt*((canvas.width+canvas.height)/2.0);
    for (let i=1; i<=arrWidth-2; i++) {
      for (let j=1; j<=arrHeight-2; j++) {
        x = i-dt0*u[i][j];
        y = j-dt0*v[i][j];
        if (x<0.5) {x=0.5;}
        if (x>canvas.width+0.5) {x=canvas.width+ 0.5;}
        i0=Math.floor(x);
        i1=i0+1;
        if (y<0.5) {y=0.5;}
        if (y>canvas.height+0.5) {y=canvas.height+ 0.5;}
        j0=Math.floor(y);
        j1=j0+1;
        s1 = x-i0;
        s0 = 1-s1;
        t1 = y-j0;
        t0 = 1-t1;
        d[i][j] = s0 * ( t0*d0[i0][j0] + t1*d0[i0][j1] ) +
          s1 * ( t0*d0[i1][j0] + t1*d0[i1][j1] );
      }
    }
    // set_bnd ( N, b, d );
  }

  // function project( int N, float * u, float * v, float * p, float * div )
  // {
    // int i, j, k;
    // float h;
    // h = 1.0/N;
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // div[IX(i,j)] = -0.5*h*(u[IX(i+1,j)]-u[IX(i-1,j)]+
    // v[IX(i,j+1)]-v[IX(i,j-1)]);
    // p[IX(i,j)] = 0;
    // }
    // }
    // set_bnd ( N, 0, div ); set_bnd ( N, 0, p );
    // for ( k=0 ; k<20 ; k++ ) {
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // p[IX(i,j)] = (div[IX(i,j)]+p[IX(i-1,j)]+p[IX(i+1,j)]+
    //  p[IX(i,j-1)]+p[IX(i,j+1)])/4;
    // }
    // }
    // set_bnd ( N, 0, p );
    // }
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // u[IX(i,j)] -= 0.5*(p[IX(i+1,j)]-p[IX(i-1,j)])/h;
    // v[IX(i,j)] -= 0.5*(p[IX(i,j+1)]-p[IX(i,j-1)])/h;
    // }
    // }
    // set_bnd ( N, 1, u ); set_bnd ( N, 2, v );
  // }

  function swap(matA, matB) {
    const tmp = matB;
    matB = matA;
    matA = tmp;
  }

  function add_den_source() {
    denPrev[5][5] += 4;
  }

  function add_vel_source() {
    const newRandVec = function(v) { return v+(Math.random()-0.5)*0.001; };
    uState = uState.map(row => row.map(el => newRandVec(el)));
    vState = vState.map(row => row.map(el => newRandVec(el)));
  }

  function densityEvolve() {
    add_den_source();
    swap(denState, denPrev);
    diffuse(1, denState, denPrev, visc, dt);
    swap(denState, denPrev);
    advect(1, denState, denPrev, uState, vState, dt);
    swap(denState, denPrev);
  }

  function arraysEqual(arr1, arr2) {
    if(arr1.length !== arr2.length)
        return false;
    for(var i = arr1.length; i--;) {
        if(arr1[i] !== arr2[i])
            return false;
    }

    return true;
  }

  function vel_evolve() {
    add_vel_source();
    swap(uState, uPrev);
    swap(vState, vPrev);
    diffuse(1, uState, uPrev, visc, dt);
    diffuse(1, vState, vPrev, visc, dt);
    // project ( N, u, v, u0, v0 );
    swap(uState, uPrev);
    swap(vState, vPrev);
    // advect(1, vState, vPrev, vPrev, uPrev, dt);
    // project ( N, u, v, u0, v0 );
  }

  const lifeCycle = function() {
    densityEvolve();
    vel_evolve();
    drawCanvas();
    drawDensityCircles();
    drawVelocityArrows();
    denPrev = matrixDeepCopy(denState);
    console.log(' _tick _ ');
    setTimeout(lifeCycle, 100);
  }

  setTimeout(lifeCycle, 100);
</script>

</body>
</html>
