<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>
<body style="text-align:center; margin-left:auto; margin-right:auto;">

<canvas id="draw" width="1265" height="492"></canvas>
<button onclick="reset();">Reset</button>
<button onclick="pauseOrPlay();" id="pauseOrPlay">Pause</button>

<script type="text/javascript">
  // https://pdfs.semanticscholar.org/847f/819a4ea14bd789aca8bc88e85e906cfc657c.pdf
  const canvas = document.querySelector('#draw');
  ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'lightgrey';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeRect(0, 0, canvas.width, canvas.height);

  const pixelSize = 20;
  let dt = 0.002;
  const visc = 800;
  const arrWidth = Math.floor(canvas.width / pixelSize);
  const arrHeight = Math.floor(canvas.height / pixelSize);
  const Nx = arrWidth-2;
  const Ny = arrHeight-2;
  const denVelRatio = 0.4;

  let isMouseDown = false;
  let paused = false;

  function initMatrix(x,y,val=function() { return 0; }) {
    const matrix = [];
    for(var i=0; i<x; i++) {
      let innerMat = [];
      for (let j=0; j<y; j++) {
        innerMat.push(val(i,j));
      }
      matrix[i] = innerMat;
    }
    return matrix;
  }

  function matrixDeepCopy(mat) {
    return mat.slice().map(el => el.slice());
  }

  function clearMatrix(mat) {
    mat = mat.map(row => row.fill(0));
  }

  canvas.addEventListener('mousedown', clickFromUser);
  canvas.addEventListener('mouseup', mouseupFromUser);
  canvas.addEventListener('mousemove', mousemoveFromUser);
  function clickFromUser($event) {
    console.log('CLICK');
    isMouseDown = true;
    denInput[Math.floor($event.offsetX/pixelSize)][Math.floor($event.offsetY/pixelSize)] = 1;
  }
  function mouseupFromUser() {
    isMouseDown = false;
    clearMatrix(denInput);
  }
  function mousemoveFromUser($event) {
    if (!isMouseDown || denInput[Math.floor($event.offsetX/pixelSize)][Math.floor($event.offsetY/pixelSize)] !== 0) { return; }
    denInput[Math.floor($event.offsetX/pixelSize)][Math.floor($event.offsetY/pixelSize)] = 1;
  }
  let uState, vState, uPrev, vPrev, denState, denPrev, denInput;

  function resetState() {
    const newVec = function() { return 0; };
    // const newVec = function() { return (Math.random()-0.5)*0.01 };
    const newVecU = (x,y) => { return Math.sin(-0.002*x*y-10)/denVelRatio; };
    const newVecV = (x,y) => { return Math.cos(-0.015*x*y-10)/-denVelRatio; };
    uState = initMatrix(arrWidth, arrHeight, newVecU);
    vState = initMatrix(arrWidth, arrHeight, newVecV);
    uPrev = matrixDeepCopy(uState);
    vPrev = matrixDeepCopy(vState);
    const newScalar = function() { return Math.random() * denVelRatio; }
    denState = initMatrix(arrWidth, arrHeight, newScalar);
    denPrev = matrixDeepCopy(denState);
    denInput = initMatrix(arrWidth, arrHeight, () => 0);
  }

  function drawCanvas() {
    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(0, 0, arrWidth*pixelSize, arrHeight*pixelSize);
    ctx.strokeRect(0, 0, arrWidth*pixelSize, arrHeight*pixelSize);
    ctx.strokeStyle = "grey";
  }

  function drawCanvasArrow(fromX, fromY, toX, toY) {
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
  }

  function drawVelocityArrows() {
    const displayAmplitude = 2 * denVelRatio;
    for (let i=0; i<arrWidth; i++) {
      for (let j=0; j<arrHeight; j++) {
        const uDot = uState[i][j];
        const vDot = vState[i][j];
        if (uDot == vDot && vDot == 0) { continue; }
        drawCanvasArrow(
          (i+1)*pixelSize-pixelSize/2.0,
          (j+1)*pixelSize-pixelSize/2.0,
          (i+1)*pixelSize-pixelSize/2.0 + pixelSize/2.0*uDot*displayAmplitude,
          (j+1)*pixelSize-pixelSize/2.0 + pixelSize/2.0*vDot*displayAmplitude
        );
      }
    }
  }

  const displayCircles = false;
  const blurOffsetY = canvas.height + 1000;

  const skipDrawOptimize = false;
  const skipDrawRate = 3;

  const denDiffOptimize = false;
  const denDiffReq = 0.01;
  const denDiffPrev = initMatrix(arrWidth, arrHeight, () => 0);
  const refreshAnywayRate = 23;

  function drawDensityCircles() {
    ctx.strokeStyle = "black";
    if (displayCircles) {
      ctx.shadowOffsetY = blurOffsetY;
      ctx.shadowBlur = pixelSize; // (default 0)
      ctx.shadowColor = 'rgba(0,0,0,1)'; // (default transparent black)
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,1)'; // transparent black, aka the default pixel state of a canvas
    }
    for (let i=0; i<arrWidth; i++) {
      for (let j=0; j<arrHeight; j++) {
        const skipNum = (i+(j*arrWidth)+(cycleCount*7));
        if (skipDrawOptimize && skipNum%skipDrawRate === 0) { continue; }
        if (denDiffOptimize && skipNum%refreshAnywayRate != 0 && denState[i][j]-denDiffPrev[i][j] < denDiffReq) { continue; }
        denDiffPrev[i][j] = denState[i][j];
        const denX = (i+1)*pixelSize-pixelSize/2.0;
        const denY = (j+1)*pixelSize-pixelSize/2.0;
        const denSize = denState[i][j]*10 / denVelRatio;
        displayCircles ? canvasGradient(denX, denY, denSize) : canvasShadedSquare(denX, denY, denSize);
      }
    }
    if (displayCircles) {
      ctx.closePath();
      ctx.fill();
    }
  }

  function canvasCircle(x, y, radius) {
    ctx.beginPath();
    ctx.arc(
      x, y, radius,
      0, 2*Math.PI, false
    );
    ctx.stroke();
  }

  function canvasShadedSquare(x, y, radius) {
    const shadeRatio = 256/10.0;
    const squareShade = shadeRatio * radius;
    ctx.fillStyle = `rgb(${squareShade}, ${squareShade}, ${squareShade})`;
    ctx.beginPath();
    ctx.fillRect(x-pixelSize/2.0, y-pixelSize/2.0, pixelSize*2, pixelSize*2);
  }

  function canvasGradient(x, y, radius) {
    ctx.moveTo(x, y);
    ctx.arc(x, y-blurOffsetY, radius*2.0*pixelSize/20.0, 0, Math.PI * 2, true );
  }

  function diffuse(b, x, x0, visc, dt) {
    const a=dt*visc;
    for (let k=0; k<20; k++ ) {
      for (let i=1; i<=Nx; i++ ) {
        for (let j=1; j<=Ny; j++ ) {
          x[i][j] = (
            x0[i][j] +
            a*(
              x[i-1][j]+
              x[i+1][j]+
              x[i][j-1]+
              x[i][j+1]
            )
          )/(1+4*a);
        }
      }
      set_bnd(b, x);
    }
  }

  function advect(b, d, d0, u, v, dt) {
    let x, y, s0, t0, s1, t1, dt0;
    dt0 = dt*((arrWidth+arrHeight-4)/2.0);
    for (let i=1; i<=Nx; i++) {
      for (let j=1; j<=Ny; j++) {
        x = i-dt0*u[i][j];
        y = j-dt0*v[i][j];
        if (x<0.5) { x=0.5; }
        if (x>arrWidth-0.5) { x=arrWidth-0.5; }
        i0=Math.floor(x);
        i1=i0+1;
        if (y<0.5) { y=0.5; }
        if (y>arrHeight-0.5) { y=arrHeight-0.5; }
        j0=Math.floor(y);
        j1=j0+1;
        s1 = x-i0;
        s0 = 1-s1;
        t1 = y-j0;
        t0 = 1-t1;
        d[i][j] = s0 * ( t0*d0[i0][j0] + t1*d0[i0][j1] ) +
          s1 * ( t0*d0[i1][j0] + t1*d0[i1][j1] );
      }
    }
    set_bnd ( b, d );
  }

  function project(u, v, p, div) {
    const totalArea = (Nx*Ny)/2.0;
    const h = 1.0/(totalArea);
    for ( let i=1; i<=Nx; i++ ) {
      for ( let j=1; j<=Ny; j++ ) {
        div[i][j] = -0.5*h*(
          u[i+1][j]-u[i-1][j] +
          v[i][j+1]-v[i][j-1]
        );
        p[i][j] = 0;
      }
    }
    set_bnd ( 0, div );
    set_bnd ( 0, p );
    for ( let k=0; k<20; k++) {
      for ( let i=1; i<=Nx; i++ ) {
        for ( let j=1; j<=Ny; j++ ) {
          p[i][j] = (
            div[i][j]+
            p[i-1][j]+
            p[i+1][j]+
            p[i][j-1]+
            p[i][j+1]
          )/4.0;
        }
      }
      set_bnd ( 0, p );
    }
    for ( let i=1; i<=Nx; i++ ) {
      for ( let j=1; j<=Ny; j++ ) {
        u[i][j] -= 0.5*( p[i+1][j] - p[i-1][j] )/h;
        v[i][j] -= 0.5*( p[i][j+1] - p[i][j-1] )/h;
      }
    }
    set_bnd ( 1, u );
    set_bnd ( 2, v );
  }

//   void project ( int N, float * u, float * v, float * p, float * div )
  // {
    // int i, j, k;
    // float h;
    // h = 1.0/N;
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // div[IX(i,j)] = -0.5*h*(u[IX(i+1,j)]-u[IX(i-1,j)]+
    // v[IX(i,j+1)]-v[IX(i,j-1)]);
    // p[IX(i,j)] = 0;
    // }
    // }
    // set_bnd ( N, 0, div ); set_bnd ( N, 0, p );
    // for ( k=0 ; k<20 ; k++ ) {
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // p[IX(i,j)] = (div[IX(i,j)]+p[IX(i-1,j)]+p[IX(i+1,j)]+
    //  p[IX(i,j-1)]+p[IX(i,j+1)])/4;
    // }
    // }
    // set_bnd ( N, 0, p );
    // }
    // for ( i=1 ; i<=N ; i++ ) {
    // for ( j=1 ; j<=N ; j++ ) {
    // u[IX(i,j)] -= 0.5*(p[IX(i+1,j)]-p[IX(i-1,j)])/h;
    // v[IX(i,j)] -= 0.5*(p[IX(i,j+1)]-p[IX(i,j-1)])/h;
    // }
    // }
    // set_bnd ( N, 1, u ); set_bnd ( N, 2, v );
  // }

  function set_bnd(b, x) {
    for ( let j=1; j<=arrHeight-2; j++ ) {
      // console.log(x[0][j]);
      x[0][j] = (b==1) ? Math.abs(x[1][j]) : x[1][j];
      // console.log(x[0][j], b, x[1][j]);
      x[arrWidth-1][j] = (b==1) ? -Math.abs(x[arrWidth-2][j]) : x[arrWidth-2][j];
    }
    for ( let i=1; i<=arrWidth-2; i++ ) {
      x[i][0] = (b==2) ? Math.abs(x[i][1]) : x[i][1];
      x[i][arrHeight-1] = (b==2) ? -Math.abs(x[i][arrHeight-2]) : x[i][arrHeight-2];
    }
    x[0][0] = 0.5*(x[1][0]+x[0][1]);
    x[0][Ny+1] = 0.5*(x[1][Ny+1]+x[0][Ny]);
    x[Nx+1][0] = 0.5*(x[Nx][0]+x[Nx+1][1]);
    x[Nx+1][Ny+1] = 0.5*(x[Nx][Ny+1]+x[Nx+1][Ny]);
  }

// void set_bnd ( int N, int b, flo at * x )
// {
// int i;
// for ( i=1 ; i<=N ; i++ ) {
// x[IX(0 ,i)] = b==1 ? 窶度[IX(1,i)] : x[IX(1,i)];
// x[IX(N+1,i)] = b==1 ? 窶度[IX(N,i)] : x[IX(N,i)];
// x[IX(i,0 )] = b==2 ? 窶度[IX(i,1)] : x[IX(i,1)];
// x[IX(i,N+1)] = b==2 ? 窶度[IX(i,N)] : x[IX(i,N)];
// }
// x[IX(0 ,0 )] = 0.5*(x[IX(1,0 )]+x[IX(0 ,1)]);
// x[IX(0 ,N+1)] = 0.5*(x[IX(1,N+1)]+x[IX(0 ,N )]);
// x[IX(N+1,0 )] = 0.5*(x[IX(N,0 )]+x[IX(N+1,1)]);
// x[IX(N+1,N+1)] = 0.5*(x[IX(N,N+1)]+x[IX(N+1,N )]);
// }

  function swap(matA, matB) {
    const tmp = matB;
    matB = matA;
    matA = tmp;
  }

  // function add_source(x, s, dt) {
  //   for ( let i=0; i<arrWidth; i++ ) {
  //     for ( let j=0; j<arrWidth; j++) {
  //       x[i][j] += dt*s[i][j];
  //     }
  //   }
  // }

  function add_den_input(m) {
    const inputMult = 2000 * denVelRatio;
    const valAt = (x,y) => {
      if (denInput[x][y] <= 0) { return 0; }
      // console.log(x,y,denInput[x][y]*inputMult*dt);
      return denInput[x][y]*inputMult*dt;
    }
    m = initMatrix(arrWidth, arrHeight, valAt);
    // for ( let i=0; i<=arrWidth-1; i++ ) {
    //   for ( let j=0; j<=arrHeight-1; j++ ) {
    //     if (denInput[i][j] <= 0) { continue; }
    //     denPrev[i][j] += denInput[i][j]*inputMult*dt;
    //   }
    // }
  }

  function add_vel_input(u, v) {
    const inputMult = 2000000 / denVelRatio;
    const uValAt = (x,y) => {
      if (
        denInput[x+1] == undefined ||
        denInput[x-1] == undefined
      ) { return 0; }
      const rght = Math.max(denInput[x+1][y], 0);
      const lft = Math.max(denInput[x-1][y], 0);

      // if (denInput[x+1][y] != 0 || denInput[x-1][y] != 0) { console.log('velu',inputMult * dt * (
      //     - rght
      //     + lft
      //   )); }

      return inputMult * dt * (
          - rght
          + lft
        );
    }
    const vValAt = (x,y) => {
      if (
        denInput[x][y+1] === undefined ||
        denInput[x][y-1] === undefined
      ) { return 0; }

      const rght = Math.max(denInput[x][y+1], 0);
      const lft = Math.max(denInput[x][y-1], 0);

      // if (denInput[x][y+1] != 0 || denInput[x][y-1] != 0) { console.log('velv',rght,lft); }

      return inputMult * dt * (
          - rght
          + lft
        );
    }
    u = initMatrix(arrWidth, arrHeight, uValAt);
    v = initMatrix(arrWidth, arrHeight, vValAt);

    // for ( let i=1; i<=arrWidth-2; i++ ) {
    //   for ( let j=1; j<=arrHeight-2; j++ ) {
    //     if (denInput[i][j] <= 0) { continue; }
    //     u[i-1][j] -= denInput[i][j]*inputMult*dt;
    //     u[i+1][j] += denInput[i][j]*inputMult*dt;
    //     v[i][j-1] -= denInput[i][j]*inputMult*dt;
    //     v[i][j+1] += denInput[i][j]*inputMult*dt;
    //   }
    // }
  }

  function densityEvolve() {
    add_den_input(denState);
    // denPrev = initMatrix(arrWidth, arrHeight, ()=>0);
    // add_source(denState, denPrev, dt);
    // swap(denState, denPrev);
    diffuse(0, denState, denPrev, visc, dt);
    // swap(denState, denPrev);
    advect(0, denState, denPrev, uState, vState, dt);
  }

  function vel_evolve() {
    // add_source(uState, uPrev, dt);
    // add_source(vState, vPrev, dt);
    add_vel_input(uState, vState);
    // uPrev = initMatrix(arrWidth, arrHeight, ()=>0);
    // vPrev = initMatrix(arrWidth, arrHeight, ()=>0);
    // swap(uState, uPrev);
    // swap(vState, vPrev);
    diffuse(1, uState, uPrev, visc, dt);
    diffuse(2, vState, vPrev, visc, dt);
    // project(uState, vState, uPrev, vPrev);
    // swap(uState, uPrev);
    // swap(vState, vPrev);
    advect(1, uState, uPrev, uPrev, vPrev, dt);
    advect(2, vState, vPrev, uPrev, vPrev, dt);
    // project(uState, vState, uPrev, vPrev);
  }

  function arraysEqual(arr1, arr2) {
    if(arr1.length !== arr2.length)
        return false;
    for(let i = arr1.length; i--;) {
        if(arr1[i] !== arr2[i])
            return false;
    }

    return true;
  }

  let tickMilliseconds = 0;
  let lifeCycleTimeout;
  let cycleCount = 0;
  const trackPerformance = false;

  const requestAnimFrame = (function(callback, tick=0){
    return  window.requestAnimationFrame  ||
      window.webkitRequestAnimationFrame  ||
      window.mozRequestAnimationFrame     ||
      function(callback){
        window.setTimeout(callback, tick);
      };
  })();

  const cancelAnimFrame = function() {
    window.cancelAnimationFrame(lifeCycleTimeout);
  }

  const lifeCycle = function() {
    if (trackPerformance) { performance.mark('lifeCycle begin'); }
    densityEvolve();
    if (trackPerformance) { performance.mark('after densityEvolve'); }
    vel_evolve();
    if (trackPerformance) { performance.mark('after velEvolve'); }
    denInput = denInput.map(row => row.map(el => el > 0 ? -el : el))
    if (!skipDrawOptimize && !denDiffOptimize) { drawCanvas(); }
    if (trackPerformance) { performance.mark('after drawCanvas'); }
    drawDensityCircles();
    if (trackPerformance) { performance.mark('after drawDensityCircles'); }
    drawVelocityArrows();
    if (trackPerformance) { performance.mark('after drawVelocityArrows'); }
    denPrev = matrixDeepCopy(denState);
    uPrev = matrixDeepCopy(uState);
    vPrev = matrixDeepCopy(vState);
    console.log(' _tick _ ');
    if (trackPerformance) { performance.mark('final marker'); }
    if (trackPerformance) {
      performance.measure('densityEvolve', 'lifeCycle begin','after densityEvolve');
      performance.measure('velEvolve', 'after densityEvolve', 'after velEvolve');
      performance.measure('drawCanvas', 'after velEvolve', 'after drawCanvas');
      performance.measure('drawDensityCircles', 'after drawCanvas', 'after drawDensityCircles');
      performance.measure('drawVelocityArrows', 'after drawDensityCircles', 'after drawVelocityArrows');
      performance.measure('frame time', 'lifeCycle begin', 'final marker');
      performance.clearMarks();
      if (cycleCount % 50 == 0) { printAndClearMeasures(); }
      cycleCount = cycleCount + 1;
    }
    lifeCycleTimeout = requestAnimFrame(lifeCycle, tickMilliseconds);
  }

  function printAndClearMeasures() {
    const allEntries = performance.getEntriesByType("measure");
    const allSortedMeasures = allEntries.reduce((acc, measure) => {
      if (acc['durations'][measure.name] === undefined) {
        acc['durations'][measure.name] = 0;
        acc['counts'][measure.name] = 0;
      }
      acc['durations'][measure.name] += measure.duration;
      acc['counts'][measure.name] += 1;
      return acc;
    }, { durations: {}, counts: {} });
    const measuresForDisplay = {
      '_fps_': `${(allSortedMeasures['counts']['frame time']*1000) / allSortedMeasures['durations']['frame time']} frame / sec`
    };
    Object.keys(allSortedMeasures['durations']).forEach(key => {
      measuresForDisplay[key] = `${allSortedMeasures['durations'][key] / allSortedMeasures['counts'][key]} milliseconds`;
    });
    console.table(measuresForDisplay);
    performance.clearMeasures();
  }

  function reset() {
    resetState();
    drawCanvas();
    drawDensityCircles();
    drawVelocityArrows();
  }
  reset();
  play();

  function pauseOrPlay() {
    paused ? play() : pause();
  }

  function pause() {
    cancelAnimFrame(lifeCycleTimeout);
    paused = true;
    const pausePlayButton = document.querySelector('#pauseOrPlay');
    pausePlayButton.innerHTML = 'Play';
    console.log('PAUSE');
  }

  function play() {
    lifeCycleTimeout = requestAnimFrame(lifeCycle, tickMilliseconds);
    paused = false;
    const pausePlayButton = document.querySelector('#pauseOrPlay');
    pausePlayButton.innerHTML = 'Pause';
    console.log('PLAY');
  }
</script>

</body>
</html>
