<!DOCTYPE html>
<html lang="en">
<body style="text-align:center; margin-left:auto; margin-right:auto;">

  <canvas id="draw" style="cursor: move; border-radius: 1px; border-style: dotted;"></canvas>
  <p><input type="range" min="0" max="100" value="50" class="slider" id="heatSlider"></p>
  <p><span id="fps-span"></span></p>
  
<script>
  const canvas = document.querySelector('#draw');
  const fpsSpan = document.querySelector('#fps-span');
  const heatSlider = document.querySelector('#heatSlider');
  const drawContext = canvas.getContext('2d');
  if (window.innerWidth >= 1200) {
    canvas.width = 1200;
    canvas.height = 492;
  } else if (window.innerWidth >= 768) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.8;
  } else {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.8;
  }

  const requestAnimFrame = ((callback) => {
    return window.requestAnimationFrame  ||
      window.webkitRequestAnimationFrame  ||
      window.mozRequestAnimationFrame     ||
      function(callback) {
        window.setTimeout(callback, 0);
      };
  })();

  const cancelAnimFrame = function() {
    window.cancelAnimationFrame(lifeCycleTimeout);
  }

  const clamp = function(num, min, max) { 
    return Math.min(Math.max(num, min), max);
  }

  function smootherstep(x) {
    return 6*x**5 - 15*x**4 + 10*x**3;
  }

  function rand_vect() {
    const theta = Math.random() * 2 * Math.PI;
    return { x: Math.cos(theta), y: Math.sin(theta) };
  }

  function gradient(x,y,gradients) {
    if (gradients[[x,y]]) return gradients[[x,y]];
    g_vect = rand_vect();
    gradients[[x, y]] = g_vect;
    return g_vect
  }

  const dot_prod_grid = function(x, y, vx, vy, gradients) {
    const g_vect = gradient(vx, vy, gradients);
    return (x - vx) * g_vect.x + (y - vy) * g_vect.y;
  }

  function interp(x, a, b) {
    return a + smootherstep(x) * (b-a);
  }

  // Special thanks to https://github.com/joeiddon/perlin
  function perlin(scale=0.1, bnd=function() { return false; }) {
    const gradients = [];
    return function(xi,yi) {
      x = xi*scale;
      y = yi*scale;
      // if (memory.hasOwnProperty([x,y]))
      //     return memory[[x,y]];
      const xf = Math.floor(x);
      const yf = Math.floor(y);
      const tl = bnd((1/scale)*xf,    (1/scale)*yf    ) ? -0.4 : dot_prod_grid(x, y, xf,   yf, gradients);
      const tr = bnd((1/scale)*(xf+1),(1/scale)*yf    ) ? -0.4 : dot_prod_grid(x, y, xf+1, yf, gradients);
      const bl = bnd((1/scale)*xf,    (1/scale)*(yf+1)) ? -0.4 : dot_prod_grid(x, y, xf,   yf+1, gradients);
      const br = bnd((1/scale)*(xf+1),(1/scale)*(yf+1)) ? -0.4 : dot_prod_grid(x, y, xf+1, yf+1, gradients);
      const xt = interp(x-xf, tl, tr);
      const xb = interp(x-xf, bl, br);
      const v = interp(y-yf, xt, xb);
      // memory[[x,y]] = v;
      return v;
    }
  }

  function randn_bm() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)
    while(v === 0) v = Math.random();
    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    num = num / 10.0 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) return randn_bm() // resample between 0 and 1
    return num
  }

  const generateStaticFn = function(n=16) {
    const cache = [];
    const cl = n*n;
    return function(x,y) {
      const coord = (x+(n*y)) % cl;
      if (cache[coord]) return cache[coord];
      const value = Math.random();
      cache[coord] = value;
      return value;
    }
  }

  const Flame = function() {
    this.pixelSize = 8;
    const nm = 32;
    this.boundaries = function(x,y) {
      if (x<=0 || x>=nm || y<=0 || y>=nm) return true;
      return false;
    }
    this.p1a = perlin(0.06,this.boundaries);
    this.p1b = perlin(0.06,this.boundaries);
    this.p2 = perlin(0.14,this.boundaries);
    this.p3a = perlin(0.14,this.boundaries);
    this.p3b = perlin(0.14,this.boundaries);
    this.st = generateStaticFn();
    
    this.draw = function(ctx, heat=0.5) {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, nm*this.pixelSize, nm*this.pixelSize);
      for (let i=0; i<nm; i++) {
        for (let j=0; j<nm; j++) {
          const denX = (i+1)*this.pixelSize-this.pixelSize/2.0;
          const denY = (j+1)*this.pixelSize-this.pixelSize/2.0;
          const denSize = clamp(this.pl(i,j,heat), 0, 1);
          this.canvasShadedSquare(ctx, denX, denY, denSize);
        }
      }
    }

    this.canvasShadedSquare = function(ctx, x, y, ss) {
      if (ss === 0) return;

      ctx.fillStyle = `rgba(255, ${interp(ss, 204, 32)}, 0, ${interp(ss, 250, 10)})`;
      const atX = x-this.pixelSize/2.0;
      const atY = y-this.pixelSize/2.0;
      ctx.fillRect(atX, atY, this.pixelSize, this.pixelSize);
    }

    this.tick = function(tickMs) {
      
      this.aorb += tickMs*0.005;
      if (this.aorb >= 1) {
        this.aorb = this.aorb % 1;
        this.p1a = this.p1b;
        this.p3a = this.p3b;
        this.p1b = perlin(0.06,this.boundaries);
        this.p3b = perlin(0.14,this.boundaries);
      }
      if (this.aorb % 3 === 0) this.st = generateStaticFn();
    }

    this.aorb = 0;
    this.pl = function(x,y,heat) { 
      const prln = (
        this.aorb*this.p1b(x,y)) +
        ((1-this.aorb)*this.p1a(x,y)) +
        (0.8*this.p2(x,y)) +
        (0.3*this.st(x,y)) +
        (this.aorb*0.8*this.p3b(x,y)) +
        ((1-this.aorb)*0.8*this.p3a(x,y)
      );
      return (
          (prln-1) / (0.5 + (heat*0.7))
        )+1;
    }
  }

  function printAndClearMeasures() {
    const allEntries = performance.getEntriesByType("measure");
    const allSortedMeasures = allEntries.reduce((acc, measure) => {
      if (acc['durations'][measure.name] === undefined) {
        acc['durations'][measure.name] = 0;
        acc['counts'][measure.name] = 0;
      }
      acc['durations'][measure.name] += measure.duration;
      acc['counts'][measure.name] += 1;
      return acc;
    }, { durations: {}, counts: {} });
    fps = Math.round((allSortedMeasures['counts']['_frame time']*1000) / allSortedMeasures['durations']['_frame time'] *100)/100;
    fpsSpan.innerHTML = `${fps} frame/sec`;
  }

  const fl = new Flame();
  let cycleCount = 0;
  let then = Date.now();
  let now;
  function cycle() {
    performance.mark('cycle begin');
    fl.draw(drawContext,heatSlider.value/100);
    now = Date.now();
    fl.tick(now - then);
    then = now;

    performance.mark('cycle end');
    performance.measure('_frame time', 'cycle begin', 'cycle end');
    if (cycleCount % 30 === 0) printAndClearMeasures();

    cycleCount += 1;
    requestAnimFrame(cycle);
  }
  cycle();

</script>

</body>
</html>
